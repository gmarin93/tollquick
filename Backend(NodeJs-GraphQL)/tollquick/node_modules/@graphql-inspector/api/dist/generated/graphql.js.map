{"version":3,"file":"graphql.js","sourceRoot":"","sources":["../../src/generated/graphql.ts"],"names":[],"mappings":";;AAGA,IAAY,gBAIX;AAJD,WAAY,gBAAgB;IAC1B,yCAAqB,CAAA;IACrB,gDAA4B,CAAA;IAC5B,2CAAuB,CAAA;AACzB,CAAC,EAJW,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAI3B","sourcesContent":["import * as core from '@graphql-inspector/core';\nexport type Maybe<T> = T | null;\n\nexport enum CriticalityLevel {\n  Breaking = 'BREAKING',\n  NonBreaking = 'NON_BREAKING',\n  Dangerous = 'DANGEROUS',\n}\n\n// ====================================================\n// Types\n// ====================================================\n\nexport interface Query {\n  readonly ping: string;\n\n  readonly coverage: SchemaCoverage;\n\n  readonly diff?: Maybe<ReadonlyArray<Change>>;\n\n  readonly validate?: Maybe<ReadonlyArray<InvalidDocument>>;\n\n  readonly similar?: Maybe<ReadonlyArray<Similar>>;\n\n  readonly similarTo: Similar;\n}\n\nexport interface SchemaCoverage {\n  readonly sources?: Maybe<ReadonlyArray<DocumentSource>>;\n\n  readonly types?: Maybe<ReadonlyArray<TypeCoverage>>;\n}\n\nexport interface DocumentSource {\n  readonly body: string;\n\n  readonly name: string;\n}\n\nexport interface TypeCoverage {\n  readonly name: string;\n\n  readonly hits: number;\n\n  readonly children?: Maybe<ReadonlyArray<TypeChildCoverage>>;\n}\n\nexport interface TypeChildCoverage {\n  readonly name: string;\n\n  readonly hits: number;\n\n  readonly locations?: Maybe<ReadonlyArray<DocumentLocation>>;\n}\n\nexport interface DocumentLocation {\n  readonly name: string;\n\n  readonly locations?: Maybe<ReadonlyArray<Location>>;\n}\n\nexport interface Location {\n  readonly start: number;\n\n  readonly end: number;\n}\n\nexport interface Change {\n  readonly message: string;\n\n  readonly path?: Maybe<string>;\n\n  readonly type: string;\n\n  readonly criticality: Criticality;\n}\n\nexport interface Criticality {\n  readonly level: CriticalityLevel;\n\n  readonly reason?: Maybe<string>;\n}\n\nexport interface InvalidDocument {\n  readonly source: DocumentSource;\n\n  readonly errors?: Maybe<ReadonlyArray<GraphQlError>>;\n}\n\nexport interface GraphQlError {\n  /** A message describing the Error for debugging purposes. */\n  readonly message: string;\n  /** An array of { line, column } locations within the source GraphQL document which correspond to this error. Errors during validation often contain multiple locations, for example to point out two things with the same name. Errors during execution include a single location, the field which produced the error. */\n  readonly locations?: Maybe<ReadonlyArray<SourceLocation>>;\n  /** An array of character offsets within the source GraphQL document which correspond to this error. */\n  readonly positions?: Maybe<ReadonlyArray<Maybe<number>>>;\n}\n\nexport interface SourceLocation {\n  readonly line: number;\n\n  readonly column: number;\n}\n\nexport interface Similar {\n  readonly name: string;\n\n  readonly best: Match;\n\n  readonly types?: Maybe<ReadonlyArray<Match>>;\n}\n\nexport interface Match {\n  readonly name: string;\n\n  readonly rating: number;\n}\n\nexport interface Mutation {\n  readonly ping: string;\n}\n\n// ====================================================\n// Arguments\n// ====================================================\n\nexport interface CoverageQueryArgs {\n  schema: string;\n\n  documents: string;\n}\nexport interface DiffQueryArgs {\n  oldSchema: string;\n\n  newSchema: string;\n}\nexport interface ValidateQueryArgs {\n  schema: string;\n\n  documents: string;\n}\nexport interface SimilarQueryArgs {\n  schema: string;\n\n  threshold?: Maybe<number>;\n}\nexport interface SimilarToQueryArgs {\n  schema: string;\n\n  name: string;\n\n  threshold?: Maybe<number>;\n}\n\nimport {GraphQLResolveInfo} from 'graphql';\n\nimport {\n  ResolvedTypeCoverage,\n  ResolvedTypeChildCoverage,\n  ResolvedDocumentLocation,\n  ResolvedSimilar,\n} from '../types';\n\nexport type Resolver<Result, Parent = {}, TContext = {}, Args = {}> = (\n  parent: Parent,\n  args: Args,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => Promise<Result> | Result;\n\nexport interface ISubscriptionResolverObject<Result, Parent, TContext, Args> {\n  subscribe<R = Result, P = Parent>(\n    parent: P,\n    args: Args,\n    context: TContext,\n    info: GraphQLResolveInfo,\n  ): AsyncIterator<R | Result> | Promise<AsyncIterator<R | Result>>;\n  resolve?<R = Result, P = Parent>(\n    parent: P,\n    args: Args,\n    context: TContext,\n    info: GraphQLResolveInfo,\n  ): R | Result | Promise<R | Result>;\n}\n\nexport type SubscriptionResolver<\n  Result,\n  Parent = {},\n  TContext = {},\n  Args = {}\n> =\n  | ((\n      ...args: any[]\n    ) => ISubscriptionResolverObject<Result, Parent, TContext, Args>)\n  | ISubscriptionResolverObject<Result, Parent, TContext, Args>;\n\nexport type TypeResolveFn<Types, Parent = {}, TContext = {}> = (\n  parent: Parent,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => Maybe<Types>;\n\nexport type NextResolverFn<T> = () => Promise<T>;\n\nexport type DirectiveResolverFn<TResult, TArgs = {}, TContext = {}> = (\n  next: NextResolverFn<TResult>,\n  source: any,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => TResult | Promise<TResult>;\n\nexport namespace QueryResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = {}> {\n    ping?: PingResolver<string, TypeParent, TContext>;\n\n    coverage?: CoverageResolver<core.SchemaCoverage, TypeParent, TContext>;\n\n    diff?: DiffResolver<Maybe<ReadonlyArray<Change>>, TypeParent, TContext>;\n\n    validate?: ValidateResolver<\n      Maybe<ReadonlyArray<InvalidDocument>>,\n      TypeParent,\n      TContext\n    >;\n\n    similar?: SimilarResolver<\n      Maybe<ReadonlyArray<ResolvedSimilar>>,\n      TypeParent,\n      TContext\n    >;\n\n    similarTo?: SimilarToResolver<ResolvedSimilar, TypeParent, TContext>;\n  }\n\n  export type PingResolver<R = string, Parent = {}, TContext = {}> = Resolver<\n    R,\n    Parent,\n    TContext\n  >;\n  export type CoverageResolver<\n    R = core.SchemaCoverage,\n    Parent = {},\n    TContext = {}\n  > = Resolver<R, Parent, TContext, CoverageArgs>;\n  export interface CoverageArgs {\n    schema: string;\n\n    documents: string;\n  }\n\n  export type DiffResolver<\n    R = Maybe<ReadonlyArray<Change>>,\n    Parent = {},\n    TContext = {}\n  > = Resolver<R, Parent, TContext, DiffArgs>;\n  export interface DiffArgs {\n    oldSchema: string;\n\n    newSchema: string;\n  }\n\n  export type ValidateResolver<\n    R = Maybe<ReadonlyArray<InvalidDocument>>,\n    Parent = {},\n    TContext = {}\n  > = Resolver<R, Parent, TContext, ValidateArgs>;\n  export interface ValidateArgs {\n    schema: string;\n\n    documents: string;\n  }\n\n  export type SimilarResolver<\n    R = Maybe<ReadonlyArray<ResolvedSimilar>>,\n    Parent = {},\n    TContext = {}\n  > = Resolver<R, Parent, TContext, SimilarArgs>;\n  export interface SimilarArgs {\n    schema: string;\n\n    threshold?: Maybe<number>;\n  }\n\n  export type SimilarToResolver<\n    R = ResolvedSimilar,\n    Parent = {},\n    TContext = {}\n  > = Resolver<R, Parent, TContext, SimilarToArgs>;\n  export interface SimilarToArgs {\n    schema: string;\n\n    name: string;\n\n    threshold?: Maybe<number>;\n  }\n}\n\nexport namespace SchemaCoverageResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = core.SchemaCoverage> {\n    sources?: SourcesResolver<\n      Maybe<ReadonlyArray<DocumentSource>>,\n      TypeParent,\n      TContext\n    >;\n\n    types?: TypesResolver<\n      Maybe<ReadonlyArray<ResolvedTypeCoverage>>,\n      TypeParent,\n      TContext\n    >;\n  }\n\n  export type SourcesResolver<\n    R = Maybe<ReadonlyArray<DocumentSource>>,\n    Parent = core.SchemaCoverage,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type TypesResolver<\n    R = Maybe<ReadonlyArray<ResolvedTypeCoverage>>,\n    Parent = core.SchemaCoverage,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace DocumentSourceResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = DocumentSource> {\n    body?: BodyResolver<string, TypeParent, TContext>;\n\n    name?: NameResolver<string, TypeParent, TContext>;\n  }\n\n  export type BodyResolver<\n    R = string,\n    Parent = DocumentSource,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type NameResolver<\n    R = string,\n    Parent = DocumentSource,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace TypeCoverageResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = ResolvedTypeCoverage> {\n    name?: NameResolver<string, TypeParent, TContext>;\n\n    hits?: HitsResolver<number, TypeParent, TContext>;\n\n    children?: ChildrenResolver<\n      Maybe<ReadonlyArray<ResolvedTypeChildCoverage>>,\n      TypeParent,\n      TContext\n    >;\n  }\n\n  export type NameResolver<\n    R = string,\n    Parent = ResolvedTypeCoverage,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type HitsResolver<\n    R = number,\n    Parent = ResolvedTypeCoverage,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type ChildrenResolver<\n    R = Maybe<ReadonlyArray<ResolvedTypeChildCoverage>>,\n    Parent = ResolvedTypeCoverage,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace TypeChildCoverageResolvers {\n  export interface Resolvers<\n    TContext = {},\n    TypeParent = ResolvedTypeChildCoverage\n  > {\n    name?: NameResolver<string, TypeParent, TContext>;\n\n    hits?: HitsResolver<number, TypeParent, TContext>;\n\n    locations?: LocationsResolver<\n      Maybe<ReadonlyArray<ResolvedDocumentLocation>>,\n      TypeParent,\n      TContext\n    >;\n  }\n\n  export type NameResolver<\n    R = string,\n    Parent = ResolvedTypeChildCoverage,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type HitsResolver<\n    R = number,\n    Parent = ResolvedTypeChildCoverage,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type LocationsResolver<\n    R = Maybe<ReadonlyArray<ResolvedDocumentLocation>>,\n    Parent = ResolvedTypeChildCoverage,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace DocumentLocationResolvers {\n  export interface Resolvers<\n    TContext = {},\n    TypeParent = ResolvedDocumentLocation\n  > {\n    name?: NameResolver<string, TypeParent, TContext>;\n\n    locations?: LocationsResolver<\n      Maybe<ReadonlyArray<Location>>,\n      TypeParent,\n      TContext\n    >;\n  }\n\n  export type NameResolver<\n    R = string,\n    Parent = ResolvedDocumentLocation,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type LocationsResolver<\n    R = Maybe<ReadonlyArray<Location>>,\n    Parent = ResolvedDocumentLocation,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace LocationResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = Location> {\n    start?: StartResolver<number, TypeParent, TContext>;\n\n    end?: EndResolver<number, TypeParent, TContext>;\n  }\n\n  export type StartResolver<\n    R = number,\n    Parent = Location,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type EndResolver<\n    R = number,\n    Parent = Location,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace ChangeResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = Change> {\n    message?: MessageResolver<string, TypeParent, TContext>;\n\n    path?: PathResolver<Maybe<string>, TypeParent, TContext>;\n\n    type?: TypeResolver<string, TypeParent, TContext>;\n\n    criticality?: CriticalityResolver<Criticality, TypeParent, TContext>;\n  }\n\n  export type MessageResolver<\n    R = string,\n    Parent = Change,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type PathResolver<\n    R = Maybe<string>,\n    Parent = Change,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type TypeResolver<\n    R = string,\n    Parent = Change,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type CriticalityResolver<\n    R = Criticality,\n    Parent = Change,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace CriticalityResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = Criticality> {\n    level?: LevelResolver<CriticalityLevel, TypeParent, TContext>;\n\n    reason?: ReasonResolver<Maybe<string>, TypeParent, TContext>;\n  }\n\n  export type LevelResolver<\n    R = CriticalityLevel,\n    Parent = Criticality,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type ReasonResolver<\n    R = Maybe<string>,\n    Parent = Criticality,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace InvalidDocumentResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = InvalidDocument> {\n    source?: SourceResolver<DocumentSource, TypeParent, TContext>;\n\n    errors?: ErrorsResolver<\n      Maybe<ReadonlyArray<GraphQlError>>,\n      TypeParent,\n      TContext\n    >;\n  }\n\n  export type SourceResolver<\n    R = DocumentSource,\n    Parent = InvalidDocument,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type ErrorsResolver<\n    R = Maybe<ReadonlyArray<GraphQlError>>,\n    Parent = InvalidDocument,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace GraphQlErrorResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = GraphQlError> {\n    /** A message describing the Error for debugging purposes. */\n    message?: MessageResolver<string, TypeParent, TContext>;\n    /** An array of { line, column } locations within the source GraphQL document which correspond to this error. Errors during validation often contain multiple locations, for example to point out two things with the same name. Errors during execution include a single location, the field which produced the error. */\n    locations?: LocationsResolver<\n      Maybe<ReadonlyArray<SourceLocation>>,\n      TypeParent,\n      TContext\n    >;\n    /** An array of character offsets within the source GraphQL document which correspond to this error. */\n    positions?: PositionsResolver<\n      Maybe<ReadonlyArray<Maybe<number>>>,\n      TypeParent,\n      TContext\n    >;\n  }\n\n  export type MessageResolver<\n    R = string,\n    Parent = GraphQlError,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type LocationsResolver<\n    R = Maybe<ReadonlyArray<SourceLocation>>,\n    Parent = GraphQlError,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type PositionsResolver<\n    R = Maybe<ReadonlyArray<Maybe<number>>>,\n    Parent = GraphQlError,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace SourceLocationResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = SourceLocation> {\n    line?: LineResolver<number, TypeParent, TContext>;\n\n    column?: ColumnResolver<number, TypeParent, TContext>;\n  }\n\n  export type LineResolver<\n    R = number,\n    Parent = SourceLocation,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type ColumnResolver<\n    R = number,\n    Parent = SourceLocation,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace SimilarResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = ResolvedSimilar> {\n    name?: NameResolver<string, TypeParent, TContext>;\n\n    best?: BestResolver<Match, TypeParent, TContext>;\n\n    types?: TypesResolver<Maybe<ReadonlyArray<Match>>, TypeParent, TContext>;\n  }\n\n  export type NameResolver<\n    R = string,\n    Parent = ResolvedSimilar,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type BestResolver<\n    R = Match,\n    Parent = ResolvedSimilar,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type TypesResolver<\n    R = Maybe<ReadonlyArray<Match>>,\n    Parent = ResolvedSimilar,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace MatchResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = Match> {\n    name?: NameResolver<string, TypeParent, TContext>;\n\n    rating?: RatingResolver<number, TypeParent, TContext>;\n  }\n\n  export type NameResolver<\n    R = string,\n    Parent = Match,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n  export type RatingResolver<\n    R = number,\n    Parent = Match,\n    TContext = {}\n  > = Resolver<R, Parent, TContext>;\n}\n\nexport namespace MutationResolvers {\n  export interface Resolvers<TContext = {}, TypeParent = {}> {\n    ping?: PingResolver<string, TypeParent, TContext>;\n  }\n\n  export type PingResolver<R = string, Parent = {}, TContext = {}> = Resolver<\n    R,\n    Parent,\n    TContext\n  >;\n}\n\n/** Directs the executor to skip this field or fragment when the `if` argument is true. */\nexport type SkipDirectiveResolver<Result> = DirectiveResolverFn<\n  Result,\n  SkipDirectiveArgs,\n  {}\n>;\nexport interface SkipDirectiveArgs {\n  /** Skipped when true. */\n  if: boolean;\n}\n\n/** Directs the executor to include this field or fragment only when the `if` argument is true. */\nexport type IncludeDirectiveResolver<Result> = DirectiveResolverFn<\n  Result,\n  IncludeDirectiveArgs,\n  {}\n>;\nexport interface IncludeDirectiveArgs {\n  /** Included when true. */\n  if: boolean;\n}\n\n/** Marks an element of a GraphQL schema as no longer supported. */\nexport type DeprecatedDirectiveResolver<Result> = DirectiveResolverFn<\n  Result,\n  DeprecatedDirectiveArgs,\n  {}\n>;\nexport interface DeprecatedDirectiveArgs {\n  /** Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax (as specified by [CommonMark](https://commonmark.org/). */\n  reason?: string;\n}\n\nexport type IResolvers<TContext = {}> = {\n  Query?: QueryResolvers.Resolvers<TContext>;\n  SchemaCoverage?: SchemaCoverageResolvers.Resolvers<TContext>;\n  DocumentSource?: DocumentSourceResolvers.Resolvers<TContext>;\n  TypeCoverage?: TypeCoverageResolvers.Resolvers<TContext>;\n  TypeChildCoverage?: TypeChildCoverageResolvers.Resolvers<TContext>;\n  DocumentLocation?: DocumentLocationResolvers.Resolvers<TContext>;\n  Location?: LocationResolvers.Resolvers<TContext>;\n  Change?: ChangeResolvers.Resolvers<TContext>;\n  Criticality?: CriticalityResolvers.Resolvers<TContext>;\n  InvalidDocument?: InvalidDocumentResolvers.Resolvers<TContext>;\n  GraphQlError?: GraphQlErrorResolvers.Resolvers<TContext>;\n  SourceLocation?: SourceLocationResolvers.Resolvers<TContext>;\n  Similar?: SimilarResolvers.Resolvers<TContext>;\n  Match?: MatchResolvers.Resolvers<TContext>;\n  Mutation?: MutationResolvers.Resolvers<TContext>;\n} & {[typeName: string]: never};\n\nexport type IDirectiveResolvers<Result> = {\n  skip?: SkipDirectiveResolver<Result>;\n  include?: IncludeDirectiveResolver<Result>;\n  deprecated?: DeprecatedDirectiveResolver<Result>;\n} & {[directiveName: string]: never};\n"]}