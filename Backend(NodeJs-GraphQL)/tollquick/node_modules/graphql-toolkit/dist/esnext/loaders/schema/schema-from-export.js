import * as AggregateError from 'aggregate-error';
import { existsSync } from 'fs';
import { extname, isAbsolute, resolve as resolvePath } from 'path';
import * as isValidPath from 'is-valid-path';
import { buildASTSchema, buildClientSchema, GraphQLSchema, parse } from 'graphql';
import { isGraphQLFile } from './schema-from-typedefs';
import * as isGlob from 'is-glob';
import { sync as globSync } from 'glob';
import { mergeTypeDefs } from '../../epoxy';
export class SchemaFromExport {
    static getFiles(globOrValidPath) {
        return (isGlob(globOrValidPath)
            ? globSync(globOrValidPath, {
                absolute: true,
                cwd: process.cwd(),
            })
            : [globOrValidPath]).filter(file => !file.includes('node_modules') && !file.endsWith('.d.ts') && !file.endsWith('.spec.ts'));
    }
    async resolveExports(file) {
        const fullPath = isAbsolute(file) ? file : resolvePath(process.cwd(), file);
        if (isValidPath(file) && existsSync(fullPath) && extname(file) !== '.json' && !isGraphQLFile(fullPath)) {
            try {
                const fileExport = await eval(`require('${fullPath}')`);
                return { ok: true, export: fileExport };
            }
            catch (e) {
                return { ok: false };
            }
        }
        return { ok: false };
    }
    async canHandle(globOrValidPath) {
        const files = SchemaFromExport.getFiles(globOrValidPath);
        for (let file of files) {
            const fullPath = isAbsolute(file) ? file : resolvePath(process.cwd(), file);
            if (isValidPath(file) && existsSync(fullPath) && extname(file) !== '.json' && !isGraphQLFile(fullPath)) {
                const validRequire = await this.resolveExports(file);
                if (!validRequire.ok) {
                    return false;
                }
                const fileExports = validRequire.export;
                const schema = await (fileExports.default || fileExports.schema || fileExports);
                if (this.isSchemaObject(schema) || this.isSchemaAst(schema) || this.isSchemaText(schema) || this.isWrappedSchemaJson(schema) || this.isSchemaJson(schema)) {
                    return true;
                }
                return false;
            }
        }
        return false;
    }
    async handle(globOrValidPath, _options) {
        const files = SchemaFromExport.getFiles(globOrValidPath);
        const filtered = await files.filter(async (file) => await this.canHandle(file));
        const schemas = await Promise.all(filtered.map(async (file) => {
            const fullPath = isAbsolute(file) ? file : resolvePath(process.cwd(), file);
            if (existsSync(fullPath)) {
                try {
                    const exports = await eval(`require('${fullPath}')`);
                    if (exports) {
                        let rawExport = exports.default || exports.schema || exports;
                        if (rawExport) {
                            let schema = await rawExport;
                            schema = await (schema.default || schema.schema || schema);
                            try {
                                return await this.resolveSchema(schema);
                            }
                            catch (e) {
                                throw new Error('Exported schema must be of type GraphQLSchema, text, AST, or introspection JSON.');
                            }
                        }
                        else {
                            throw new Error(`Invalid export from export file ${fullPath}: missing default export or 'schema' export!`);
                        }
                    }
                    else {
                        throw new Error(`Invalid export from export file ${fullPath}: empty export!`);
                    }
                }
                catch (e) {
                    console.warn(`Invalid export from export file ${fullPath}: missing default export or 'schema' export!`);
                    throw new AggregateError([new Error(`Unable to load schema from file "${file}" due to import error: ${e}`), e]);
                }
            }
            else {
                throw new Error(`Unable to locate introspection from export file: ${fullPath}`);
            }
        }));
        if (schemas.length === 1) {
            return schemas[0];
        }
        const node = mergeTypeDefs(schemas);
        return buildASTSchema(node);
    }
    isSchemaText(obj) {
        return typeof obj === 'string';
    }
    isWrappedSchemaJson(obj) {
        const json = obj;
        return json.data !== undefined && json.data.__schema !== undefined;
    }
    isSchemaJson(obj) {
        const json = obj;
        return json !== undefined && json.__schema !== undefined;
    }
    isSchemaObject(obj) {
        return obj instanceof GraphQLSchema;
    }
    isSchemaAst(obj) {
        return obj.kind !== undefined;
    }
    isPromise(obj) {
        return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
    }
    async resolveSchema(schema) {
        if (this.isSchemaObject(schema)) {
            return schema;
        }
        else if (this.isSchemaText(schema)) {
            const ast = parse(schema);
            return buildASTSchema(ast);
        }
        else if (this.isWrappedSchemaJson(schema)) {
            return buildClientSchema(schema.data);
        }
        else if (this.isSchemaJson(schema)) {
            return buildClientSchema(schema);
        }
        else if (this.isSchemaAst(schema)) {
            return schema;
        }
        else {
            throw new Error('Unexpected schema type provided!');
        }
    }
}
//# sourceMappingURL=schema-from-export.js.map